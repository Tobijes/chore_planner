# Autogenerated using ProtoBuf.jl v1.2.0 on 2026-02-06T15:20:51.059
# original file: /home/tobijes/dev/chore_planner/protobuf/choreplanner.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export TaskAssignment, TaskDef, UserAssignment, JobRequest, PeriodSchedule, JobResult


struct TaskAssignment
    label::String
    workload::Int32
end
PB.default_values(::Type{TaskAssignment}) = (;label = "", workload = zero(Int32))
PB.field_numbers(::Type{TaskAssignment}) = (;label = 1, workload = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:TaskAssignment})
    label = ""
    workload = zero(Int32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            label = PB.decode(d, String)
        elseif field_number == 2
            workload = PB.decode(d, Int32)
        else
            Base.skip(d, wire_type)
        end
    end
    return TaskAssignment(label, workload)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::TaskAssignment)
    initpos = position(e.io)
    !isempty(x.label) && PB.encode(e, 1, x.label)
    x.workload != zero(Int32) && PB.encode(e, 2, x.workload)
    return position(e.io) - initpos
end
function PB._encoded_size(x::TaskAssignment)
    encoded_size = 0
    !isempty(x.label) && (encoded_size += PB._encoded_size(x.label, 1))
    x.workload != zero(Int32) && (encoded_size += PB._encoded_size(x.workload, 2))
    return encoded_size
end

struct TaskDef
    label::String
    frequency::Int32
    workload::Int32
    force_alternation::Bool
end
PB.default_values(::Type{TaskDef}) = (;label = "", frequency = zero(Int32), workload = zero(Int32), force_alternation = false)
PB.field_numbers(::Type{TaskDef}) = (;label = 1, frequency = 2, workload = 3, force_alternation = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:TaskDef})
    label = ""
    frequency = zero(Int32)
    workload = zero(Int32)
    force_alternation = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            label = PB.decode(d, String)
        elseif field_number == 2
            frequency = PB.decode(d, Int32)
        elseif field_number == 3
            workload = PB.decode(d, Int32)
        elseif field_number == 4
            force_alternation = PB.decode(d, Bool)
        else
            Base.skip(d, wire_type)
        end
    end
    return TaskDef(label, frequency, workload, force_alternation)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::TaskDef)
    initpos = position(e.io)
    !isempty(x.label) && PB.encode(e, 1, x.label)
    x.frequency != zero(Int32) && PB.encode(e, 2, x.frequency)
    x.workload != zero(Int32) && PB.encode(e, 3, x.workload)
    x.force_alternation != false && PB.encode(e, 4, x.force_alternation)
    return position(e.io) - initpos
end
function PB._encoded_size(x::TaskDef)
    encoded_size = 0
    !isempty(x.label) && (encoded_size += PB._encoded_size(x.label, 1))
    x.frequency != zero(Int32) && (encoded_size += PB._encoded_size(x.frequency, 2))
    x.workload != zero(Int32) && (encoded_size += PB._encoded_size(x.workload, 3))
    x.force_alternation != false && (encoded_size += PB._encoded_size(x.force_alternation, 4))
    return encoded_size
end

struct UserAssignment
    user_name::String
    tasks::Vector{TaskAssignment}
end
PB.default_values(::Type{UserAssignment}) = (;user_name = "", tasks = Vector{TaskAssignment}())
PB.field_numbers(::Type{UserAssignment}) = (;user_name = 1, tasks = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:UserAssignment})
    user_name = ""
    tasks = PB.BufferedVector{TaskAssignment}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            user_name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, tasks)
        else
            Base.skip(d, wire_type)
        end
    end
    return UserAssignment(user_name, tasks[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::UserAssignment)
    initpos = position(e.io)
    !isempty(x.user_name) && PB.encode(e, 1, x.user_name)
    !isempty(x.tasks) && PB.encode(e, 2, x.tasks)
    return position(e.io) - initpos
end
function PB._encoded_size(x::UserAssignment)
    encoded_size = 0
    !isempty(x.user_name) && (encoded_size += PB._encoded_size(x.user_name, 1))
    !isempty(x.tasks) && (encoded_size += PB._encoded_size(x.tasks, 2))
    return encoded_size
end

struct JobRequest
    tasks::Vector{TaskDef}
    users::Vector{String}
    n_periods::Int32
end
PB.default_values(::Type{JobRequest}) = (;tasks = Vector{TaskDef}(), users = Vector{String}(), n_periods = zero(Int32))
PB.field_numbers(::Type{JobRequest}) = (;tasks = 1, users = 2, n_periods = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:JobRequest})
    tasks = PB.BufferedVector{TaskDef}()
    users = PB.BufferedVector{String}()
    n_periods = zero(Int32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, tasks)
        elseif field_number == 2
            PB.decode!(d, users)
        elseif field_number == 3
            n_periods = PB.decode(d, Int32)
        else
            Base.skip(d, wire_type)
        end
    end
    return JobRequest(tasks[], users[], n_periods)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::JobRequest)
    initpos = position(e.io)
    !isempty(x.tasks) && PB.encode(e, 1, x.tasks)
    !isempty(x.users) && PB.encode(e, 2, x.users)
    x.n_periods != zero(Int32) && PB.encode(e, 3, x.n_periods)
    return position(e.io) - initpos
end
function PB._encoded_size(x::JobRequest)
    encoded_size = 0
    !isempty(x.tasks) && (encoded_size += PB._encoded_size(x.tasks, 1))
    !isempty(x.users) && (encoded_size += PB._encoded_size(x.users, 2))
    x.n_periods != zero(Int32) && (encoded_size += PB._encoded_size(x.n_periods, 3))
    return encoded_size
end

struct PeriodSchedule
    period_number::Int32
    users::Vector{UserAssignment}
end
PB.default_values(::Type{PeriodSchedule}) = (;period_number = zero(Int32), users = Vector{UserAssignment}())
PB.field_numbers(::Type{PeriodSchedule}) = (;period_number = 1, users = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:PeriodSchedule})
    period_number = zero(Int32)
    users = PB.BufferedVector{UserAssignment}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            period_number = PB.decode(d, Int32)
        elseif field_number == 2
            PB.decode!(d, users)
        else
            Base.skip(d, wire_type)
        end
    end
    return PeriodSchedule(period_number, users[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::PeriodSchedule)
    initpos = position(e.io)
    x.period_number != zero(Int32) && PB.encode(e, 1, x.period_number)
    !isempty(x.users) && PB.encode(e, 2, x.users)
    return position(e.io) - initpos
end
function PB._encoded_size(x::PeriodSchedule)
    encoded_size = 0
    x.period_number != zero(Int32) && (encoded_size += PB._encoded_size(x.period_number, 1))
    !isempty(x.users) && (encoded_size += PB._encoded_size(x.users, 2))
    return encoded_size
end

struct JobResult
    periods::Vector{PeriodSchedule}
end
PB.default_values(::Type{JobResult}) = (;periods = Vector{PeriodSchedule}())
PB.field_numbers(::Type{JobResult}) = (;periods = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:JobResult})
    periods = PB.BufferedVector{PeriodSchedule}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, periods)
        else
            Base.skip(d, wire_type)
        end
    end
    return JobResult(periods[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::JobResult)
    initpos = position(e.io)
    !isempty(x.periods) && PB.encode(e, 1, x.periods)
    return position(e.io) - initpos
end
function PB._encoded_size(x::JobResult)
    encoded_size = 0
    !isempty(x.periods) && (encoded_size += PB._encoded_size(x.periods, 1))
    return encoded_size
end
